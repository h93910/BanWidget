package com.example.banwidgetimport android.app.*import android.content.*import android.net.ConnectivityManagerimport android.net.Networkimport android.net.NetworkRequestimport android.os.IBinderimport android.util.Logimport android.widget.Toastimport androidx.core.app.NotificationCompatimport kotlinx.coroutines.Dispatchersimport kotlinx.coroutines.GlobalScopeimport kotlinx.coroutines.delayimport kotlinx.coroutines.launchclass TimerWidgetService : Service() {    override fun onBind(intent: Intent): IBinder? {        return null    }    override fun onCreate() {        super.onCreate()        initListener()        initNotification()        Log.d(TAG, "onCreate TimerWidgetService")    }    private fun initNotification() {        val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager        val channel = NotificationChannel(CHANNEL_ID, CHANNEL_ID, NotificationManager.IMPORTANCE_HIGH)        channel.enableLights(true) //设置提示灯        channel.lightColor = android.graphics.Color.RED //设置提示灯颜色        channel.setShowBadge(true) //显示logo        channel.description = "description" //设置描述        channel.lockscreenVisibility = Notification.VISIBILITY_PUBLIC //设置锁屏可见 VISIBILITY_PUBLIC=可见        manager.createNotificationChannel(channel)        val intent = Intent(this, MainActivity::class.java)        val pendingIntent = PendingIntent.getActivity(this, 0, intent,                PendingIntent.FLAG_UPDATE_CURRENT);        val notification = NotificationCompat.Builder(this, CHANNEL_ID)                .setContentTitle(CHANNEL_ID) //标题                .setContentText(getString(R.string.notification_description)) //内容                .setWhen(System.currentTimeMillis())                .setVibrate(null)                .setContentIntent(pendingIntent)//点击打开应用                .setSmallIcon(R.drawable.ic_launcher_foreground) //小图标一定需要设置,否则会报错(如果不设置它启动服务前台化不会报错,但是你会发现这个通知不会启动),如果是普通通知,不设置必然报错//                .setLargeIcon(BitmapFactory.decodeResource(resources, R.mipmap.ic_launcher))                .build()        startForeground(1, notification) //服务前台化只能使用startForeground()方法,不能使用 notificationManager.notify(1,notification); 这个只是启动通知使用的,使用这个方法你只需要等待几秒就会发现报错了    }    private fun initListener() {        //侦听网络状态改变        val cm = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager        cm.requestNetwork(NetworkRequest.Builder().build(),                object : ConnectivityManager.NetworkCallback() {                    override fun onAvailable(network: Network) {                        super.onAvailable(network)                        Toast.makeText(this@TimerWidgetService,                                "网络状态改变了", Toast.LENGTH_SHORT).show()                        sendIntentToMyAppWidgetProvider("ban.net.conn.CONNECTIVITY_CHANGE")                    }                })        //动态注册-侦听屏幕打开        val filter = IntentFilter()        filter.addAction(Intent.ACTION_SCREEN_ON)        registerReceiver(receiver, filter)    }    private fun sendIntentToMyAppWidgetProvider(action: String) {        GlobalScope.launch(Dispatchers.Default) {            delay(3000)            val intent = Intent(action)            //api 8.0以上发给自己的必须写            intent.component = ComponentName(this@TimerWidgetService, MyAppWidgetProvider::class.java)            sendBroadcast(intent)        }    }    override fun onDestroy() {        super.onDestroy()        unregisterReceiver(receiver)        Log.d(TAG, "onDestroy TimerWidgetService")    }    override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {        // 发送广播通知 widget 更新 状态//        if (intent != null && !TextUtils.isEmpty(intent.action)) {//            sendBroadcast(Intent(intent.action).putExtra("time", System.currentTimeMillis()))//            Toast.makeText(applicationContext, intent.action, Toast.LENGTH_LONG).show()//        }        Log.d(TAG, "onStartCommand TimerWidgetService")        return START_STICKY    }    private val receiver = MyReceiver()    inner class MyReceiver : BroadcastReceiver() {        override fun onReceive(p0: Context?, p1: Intent?) {            p1?.run {                if (Intent.ACTION_SCREEN_ON == action) {                    sendIntentToMyAppWidgetProvider("on.enable.action")                }            }        }    }    companion object {        private const val TAG = "TimerWidgetService"        private const val CHANNEL_ID = TAG;    }}